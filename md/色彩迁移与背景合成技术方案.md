# NPR渲染系统功能扩展方案

## 色彩迁移 (Color Transfer) 与背景合成 (Background Composition)

---

## 目录

1. [功能概述](#功能概述)
2. [色彩迁移技术方案](#色彩迁移技术方案)
3. [背景合成技术方案](#背景合成技术方案)
4. [实现架构](#实现架构)
5. [代码示例](#代码示例)
6. [性能优化](#性能优化)
7. [参考资料](#参考资料)

---

## 功能概述

### 1.1 色彩迁移 (Color Transfer)

**目标**：允许用户上传一张参考图片（如梵高的《星空》），让3D模型的渲染结果自动采用该图片的色调风格。

**应用场景**：
- 将3D模型渲染成特定艺术家的色彩风格
- 统一多个模型的色调，制作系列作品
- 快速实现艺术化效果，无需手动调色

### 1.2 背景合成 (Background Composition)

**目标**：不使用单调的黑色背景，允许程序读取一张2D背景图片，将3D模型渲染在背景图上，利用深度图实现正确的遮挡关系。

**应用场景**：
- 将3D角色放置在真实照片背景中
- 制作电影/游戏概念图
- 增强场景的真实感和艺术感

---

## 色彩迁移技术方案

### 2.1 基于直方图匹配的方法（推荐实现）

#### 原理

直方图匹配（Histogram Matching）是将源图像的颜色分布调整为与目标图像相似的过程。

#### 核心算法

**方法1：单通道直方图匹配**

在RGB或LAB色彩空间中，对每个通道分别进行直方图匹配：

```
1. 计算源图像和目标图像的累积分布函数 (CDF)
2. 建立映射关系：source_cdf[i] → target_cdf[j]
3. 对源图像的每个像素值应用映射
```

**优点**：
- 实现简单，速度快
- OpenCV提供现成函数
- 适合实时交互

**缺点**：
- 可能产生颜色失真
- 不考虑像素间的空间关系

#### 实现步骤

```python
def histogram_matching(source, reference):
    """
    直方图匹配：将source图像的色彩迁移到reference的风格
    
    Args:
        source: 待迁移图像 (H, W, 3) RGB
        reference: 参考风格图像 (H, W, 3) RGB
    
    Returns:
        迁移后的图像
    """
    # 转换到LAB色彩空间（更符合人眼感知）
    source_lab = cv2.cvtColor(source, cv2.COLOR_RGB2LAB)
    reference_lab = cv2.cvtColor(reference, cv2.COLOR_RGB2LAB)
    
    # 对每个通道进行匹配
    matched_lab = np.zeros_like(source_lab)
    for i in range(3):
        matched_lab[:, :, i] = match_histogram_channel(
            source_lab[:, :, i], 
            reference_lab[:, :, i]
        )
    
    # 转回RGB
    result = cv2.cvtColor(matched_lab.astype(np.uint8), cv2.COLOR_LAB2RGB)
    return result
```

### 2.2 基于统计量迁移的方法

#### 原理

Reinhard等人提出的颜色迁移算法，通过匹配源图像和目标图像在LAB空间的均值和标准差来实现色彩迁移。

#### 核心公式

在LAB色彩空间中：

$$
I'_L = \frac{\sigma_t^L}{\sigma_s^L}(I_s^L - \mu_s^L) + \mu_t^L
$$

$$
I'_A = \frac{\sigma_t^A}{\sigma_s^A}(I_s^A - \mu_s^A) + \mu_t^A
$$

$$
I'_B = \frac{\sigma_t^B}{\sigma_s^B}(I_s^B - \mu_s^B) + \mu_t^B
$$

其中：
- $I_s$：源图像
- $I_t$：目标图像
- $\mu$：均值
- $\sigma$：标准差

#### 实现步骤

```python
def reinhard_color_transfer(source, reference):
    """
    Reinhard色彩迁移算法
    
    基于统计量匹配，效果更自然
    """
    # 转换到LAB空间
    source_lab = cv2.cvtColor(source, cv2.COLOR_RGB2LAB).astype(np.float32)
    reference_lab = cv2.cvtColor(reference, cv2.COLOR_RGB2LAB).astype(np.float32)
    
    # 计算统计量
    mean_src = source_lab.mean(axis=(0, 1))
    std_src = source_lab.std(axis=(0, 1))
    
    mean_ref = reference_lab.mean(axis=(0, 1))
    std_ref = reference_lab.std(axis=(0, 1))
    
    # 应用变换
    result_lab = (source_lab - mean_src) * (std_ref / std_src) + mean_ref
    result_lab = np.clip(result_lab, 0, 255).astype(np.uint8)
    
    # 转回RGB
    result = cv2.cvtColor(result_lab, cv2.COLOR_LAB2RGB)
    return result
```

**优点**：
- 效果自然，保留图像细节
- 计算量小，适合实时应用
- 理论基础扎实

**缺点**：
- 假设颜色分布为高斯分布
- 对极端色彩的处理可能不够理想

### 2.3 深度学习方法（可选扩展）

使用神经网络进行风格迁移（如Neural Style Transfer）：

**优点**：
- 效果最佳，能捕捉复杂的艺术风格
- 可以迁移纹理和笔触

**缺点**：
- 计算量大，需要GPU
- 实时性差（单张图需要数秒到数分钟）
- 需要预训练模型

**适用场景**：非实时的高质量渲染

---

## 背景合成技术方案

### 3.1 基于深度图的Alpha混合

#### 原理

利用渲染得到的深度图，生成一个Alpha遮罩（mask），将3D模型的前景与背景图像合成。

#### 实现流程

```
1. 渲染得到深度图 depth_map (H, W)
2. 生成前景遮罩 alpha_mask = (depth_map > 0).astype(float)
3. 调整背景图到相同尺寸 background_resized
4. 合成：result = foreground * alpha + background * (1 - alpha)
```

#### 代码示例

```python
def composite_with_background(rendered_image, depth_map, background_image):
    """
    将渲染结果合成到背景图上
    
    Args:
        rendered_image: NPR渲染结果 (H, W, 3)
        depth_map: 深度图 (H, W)，值为0表示背景
        background_image: 背景图片 (任意尺寸)
    
    Returns:
        合成后的图像
    """
    h, w = depth_map.shape
    
    # 调整背景图尺寸
    bg_resized = cv2.resize(background_image, (w, h), 
                            interpolation=cv2.INTER_LINEAR)
    
    # 生成Alpha遮罩
    # 对深度图进行二值化，深度>0的为前景
    alpha_mask = (depth_map > 0).astype(np.float32)
    
    # 边缘羽化，避免生硬的边界
    alpha_mask = cv2.GaussianBlur(alpha_mask, (5, 5), 0)
    alpha_mask = np.expand_dims(alpha_mask, axis=2)  # (H, W, 1)
    
    # Alpha混合
    result = (rendered_image.astype(np.float32) * alpha_mask + 
              bg_resized.astype(np.float32) * (1 - alpha_mask))
    
    return result.astype(np.uint8)
```

### 3.2 基于深度的景深效果（扩展功能）

#### 原理

根据深度信息对背景进行模糊，模拟相机的景深效果（DOF, Depth of Field），让前景更突出。

#### 实现步骤

```python
def apply_depth_of_field(background, depth_map, focus_depth=0.5, blur_strength=5):
    """
    根据深度图对背景应用景深效果
    
    Args:
        background: 背景图像
        depth_map: 深度图（0-1范围）
        focus_depth: 焦点深度
        blur_strength: 模糊强度
    
    Returns:
        应用景深效果的背景
    """
    # 计算每个像素的模糊半径
    blur_radius = np.abs(depth_map - focus_depth) * blur_strength
    blur_radius = blur_radius.astype(np.int32)
    
    # 应用可变模糊（简化版，可使用更高级的算法）
    result = background.copy()
    max_blur = int(blur_radius.max())
    
    for blur_size in range(1, max_blur + 1, 2):
        mask = (blur_radius >= blur_size).astype(np.float32)
        blurred = cv2.GaussianBlur(background, (blur_size*2+1, blur_size*2+1), 0)
        result = (result * (1 - mask[..., None]) + 
                  blurred * mask[..., None]).astype(np.uint8)
    
    return result
```

### 3.3 高级遮挡处理

#### 挑战

简单的深度图合成可能存在以下问题：
1. **边缘锯齿**：硬边界导致不自然的效果
2. **半透明处理**：头发、树叶等半透明物体
3. **抗锯齿**：模型边缘的像素走样

#### 解决方案

**1. 边缘软化（Edge Feathering）**

```python
# 使用形态学操作扩展边缘
kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
dilated = cv2.dilate(alpha_mask, kernel, iterations=1)
alpha_smooth = cv2.GaussianBlur(dilated, (5, 5), 1.5)
```

**2. 多层深度合成**

对于复杂场景，可以使用多层深度排序：

```
- 分离前景、中景、背景
- 按深度顺序依次合成
- 每层应用不同的模糊和色调
```

**3. 基于法线的边缘检测**

利用法线图检测模型轮廓，生成更精确的遮罩：

```python
def generate_accurate_mask(depth_map, normal_map, edge_threshold=0.1):
    """
    结合深度和法线生成精确遮罩
    """
    # 深度遮罩
    depth_mask = (depth_map > 0).astype(np.float32)
    
    # 法线边缘检测
    normal_edges = detect_edges(normal_map)
    
    # 结合两者
    mask = depth_mask * (1 - normal_edges * 0.5)
    
    return mask
```

---

## 实现架构

### 4.1 修改现有代码结构

在 `npr_renderer.py` 中添加新模块：

```python
class NPRRenderer:
    # 现有代码...
    
    def apply_color_transfer(self, rendered_image, reference_image, method='reinhard'):
        """应用色彩迁移"""
        if method == 'reinhard':
            return self.reinhard_color_transfer(rendered_image, reference_image)
        elif method == 'histogram':
            return self.histogram_matching(rendered_image, reference_image)
        else:
            return rendered_image
    
    def composite_background(self, rendered_image, background_path, 
                             enable_dof=False, dof_params=None):
        """背景合成"""
        background = cv2.imread(background_path)
        background = cv2.cvtColor(background, cv2.COLOR_BGR2RGB)
        
        # 应用景深效果（可选）
        if enable_dof and self.depth_map is not None:
            background = self.apply_depth_of_field(background, self.depth_map, **dof_params)
        
        # 合成
        result = self.composite_with_background(
            rendered_image, self.depth_map, background
        )
        
        return result
    
    def render(self, model, style='sketch', strength=0.9, image_size=512,
               color_reference=None, background=None):
        """
        扩展的渲染函数
        
        新增参数:
            color_reference: 色彩参考图片路径
            background: 背景图片路径
        """
        # 现有渲染流程
        result = self._original_render(model, style, strength, image_size)
        
        # 色彩迁移
        if color_reference is not None:
            ref_image = cv2.imread(color_reference)
            ref_image = cv2.cvtColor(ref_image, cv2.COLOR_BGR2RGB)
            result = self.apply_color_transfer(result, ref_image)
        
        # 背景合成
        if background is not None:
            result = self.composite_background(result, background)
        
        return result
```

### 4.2 UI界面扩展

在 `interactive_demo.py` 中添加控制组件：

```python
class NPRInteractiveApp:
    def _setup_ui(self):
        # ... 现有UI ...
        
        # 色彩迁移控制
        ttk.Label(control_frame, text="Color Reference:").pack(...)
        self.btn_load_color_ref = ttk.Button(
            control_frame, text="Load Reference Image", 
            command=self._load_color_reference
        )
        self.btn_load_color_ref.pack(...)
        
        self.var_enable_color_transfer = tk.BooleanVar(value=False)
        self.chk_color_transfer = ttk.Checkbutton(
            control_frame, text="Enable Color Transfer",
            variable=self.var_enable_color_transfer,
            command=self._trigger_full_render
        )
        self.chk_color_transfer.pack(...)
        
        # 背景合成控制
        ttk.Label(control_frame, text="Background Image:").pack(...)
        self.btn_load_background = ttk.Button(
            control_frame, text="Load Background", 
            command=self._load_background
        )
        self.btn_load_background.pack(...)
        
        self.var_enable_background = tk.BooleanVar(value=False)
        self.chk_background = ttk.Checkbutton(
            control_frame, text="Enable Background",
            variable=self.var_enable_background,
            command=self._trigger_full_render
        )
        self.chk_background.pack(...)
```

---

## 代码示例

### 5.1 完整的色彩迁移模块

```python
import numpy as np
import cv2

class ColorTransfer:
    """色彩迁移工具类"""
    
    @staticmethod
    def histogram_matching(source, reference):
        """直方图匹配方法"""
        # 转换到LAB色彩空间
        source_lab = cv2.cvtColor(source, cv2.COLOR_RGB2LAB)
        reference_lab = cv2.cvtColor(reference, cv2.COLOR_RGB2LAB)
        
        matched_lab = np.zeros_like(source_lab)
        
        for i in range(3):
            source_channel = source_lab[:, :, i].flatten()
            reference_channel = reference_lab[:, :, i].flatten()
            
            # 计算累积分布函数
            source_hist, _ = np.histogram(source_channel, bins=256, range=(0, 256))
            reference_hist, _ = np.histogram(reference_channel, bins=256, range=(0, 256))
            
            source_cdf = source_hist.cumsum()
            reference_cdf = reference_hist.cumsum()
            
            # 归一化
            source_cdf = source_cdf / source_cdf[-1]
            reference_cdf = reference_cdf / reference_cdf[-1]
            
            # 建立映射关系
            lookup_table = np.zeros(256, dtype=np.uint8)
            g_j = 0
            for g_i in range(256):
                while g_j < 255 and reference_cdf[g_j] < source_cdf[g_i]:
                    g_j += 1
                lookup_table[g_i] = g_j
            
            # 应用映射
            matched_channel = lookup_table[source_channel]
            matched_lab[:, :, i] = matched_channel.reshape(source_lab[:, :, i].shape)
        
        # 转回RGB
        result = cv2.cvtColor(matched_lab, cv2.COLOR_LAB2RGB)
        return result
    
    @staticmethod
    def reinhard_color_transfer(source, reference):
        """Reinhard色彩迁移算法"""
        # 转换到LAB空间
        source_lab = cv2.cvtColor(source, cv2.COLOR_RGB2LAB).astype(np.float32)
        reference_lab = cv2.cvtColor(reference, cv2.COLOR_RGB2LAB).astype(np.float32)
        
        # 计算统计量（只考虑非黑色像素）
        source_mask = source_lab[:, :, 0] > 10  # 排除黑色背景
        reference_mask = reference_lab[:, :, 0] > 10
        
        mean_src = [source_lab[:, :, i][source_mask].mean() for i in range(3)]
        std_src = [source_lab[:, :, i][source_mask].std() for i in range(3)]
        
        mean_ref = [reference_lab[:, :, i][reference_mask].mean() for i in range(3)]
        std_ref = [reference_lab[:, :, i][reference_mask].std() for i in range(3)]
        
        # 应用变换
        result_lab = source_lab.copy()
        for i in range(3):
            if std_src[i] > 0:
                result_lab[:, :, i] = ((source_lab[:, :, i] - mean_src[i]) * 
                                       (std_ref[i] / std_src[i]) + mean_ref[i])
        
        result_lab = np.clip(result_lab, 0, 255).astype(np.uint8)
        
        # 转回RGB
        result = cv2.cvtColor(result_lab, cv2.COLOR_LAB2RGB)
        return result
```

### 5.2 完整的背景合成模块

```python
class BackgroundCompositor:
    """背景合成工具类"""
    
    @staticmethod
    def composite_simple(foreground, depth_map, background, feather_size=5):
        """
        简单背景合成
        
        Args:
            foreground: 前景图像 (H, W, 3)
            depth_map: 深度图 (H, W)
            background: 背景图像 (任意尺寸)
            feather_size: 边缘羽化尺寸
        
        Returns:
            合成结果
        """
        h, w = depth_map.shape
        
        # 调整背景尺寸
        bg_resized = cv2.resize(background, (w, h), interpolation=cv2.INTER_LINEAR)
        
        # 生成遮罩
        alpha = (depth_map > 0).astype(np.float32)
        
        # 边缘羽化
        if feather_size > 0:
            alpha = cv2.GaussianBlur(alpha, (feather_size*2+1, feather_size*2+1), 0)
        
        alpha = np.expand_dims(alpha, axis=2)
        
        # 混合
        result = (foreground.astype(np.float32) * alpha + 
                  bg_resized.astype(np.float32) * (1 - alpha))
        
        return result.astype(np.uint8)
    
    @staticmethod
    def composite_with_dof(foreground, depth_map, background, 
                          focus_depth=0.5, blur_strength=10):
        """
        带景深效果的背景合成
        
        Args:
            foreground: 前景图像
            depth_map: 深度图（归一化到0-1）
            background: 背景图像
            focus_depth: 焦点深度
            blur_strength: 模糊强度
        """
        h, w = depth_map.shape
        bg_resized = cv2.resize(background, (w, h), interpolation=cv2.INTER_LINEAR)
        
        # 对背景应用景深模糊
        # 假设背景在最远处（depth=0）
        background_depth = 0.0
        blur_amount = int(abs(background_depth - focus_depth) * blur_strength)
        blur_amount = max(1, blur_amount)
        
        if blur_amount > 1:
            kernel_size = blur_amount * 2 + 1
            bg_blurred = cv2.GaussianBlur(bg_resized, (kernel_size, kernel_size), 0)
        else:
            bg_blurred = bg_resized
        
        # 合成
        alpha = (depth_map > 0).astype(np.float32)
        alpha = cv2.GaussianBlur(alpha, (5, 5), 0)
        alpha = np.expand_dims(alpha, axis=2)
        
        result = (foreground.astype(np.float32) * alpha + 
                  bg_blurred.astype(np.float32) * (1 - alpha))
        
        return result.astype(np.uint8)
    
    @staticmethod
    def composite_advanced(foreground, depth_map, normal_map, background, 
                          edge_threshold=0.1):
        """
        高级背景合成（使用法线辅助）
        
        提供更精确的边缘处理
        """
        h, w = depth_map.shape
        bg_resized = cv2.resize(background, (w, h), interpolation=cv2.INTER_LINEAR)
        
        # 生成基础遮罩
        alpha = (depth_map > 0).astype(np.float32)
        
        # 检测边缘
        depth_edges = cv2.Sobel(depth_map, cv2.CV_32F, 1, 0, ksize=3) + \
                      cv2.Sobel(depth_map, cv2.CV_32F, 0, 1, ksize=3)
        depth_edges = np.abs(depth_edges)
        depth_edges = cv2.normalize(depth_edges, None, 0, 1, cv2.NORM_MINMAX)
        
        # 在边缘处减少alpha值，实现半透明效果
        edge_mask = (depth_edges > edge_threshold).astype(np.float32)
        alpha = alpha * (1 - edge_mask * 0.5)
        
        # 羽化
        alpha = cv2.GaussianBlur(alpha, (7, 7), 1.5)
        alpha = np.expand_dims(alpha, axis=2)
        
        # 混合
        result = (foreground.astype(np.float32) * alpha + 
                  bg_resized.astype(np.float32) * (1 - alpha))
        
        return result.astype(np.uint8)
```

---

## 性能优化

### 6.1 色彩迁移优化

**1. 降采样预处理**

```python
def fast_color_transfer(source, reference, downsample_factor=4):
    """
    快速色彩迁移（使用降采样）
    """
    h, w = source.shape[:2]
    
    # 降采样
    source_small = cv2.resize(source, (w//downsample_factor, h//downsample_factor))
    reference_small = cv2.resize(reference, (w//downsample_factor, h//downsample_factor))
    
    # 计算统计量
    # ... Reinhard算法 ...
    
    # 直接应用到原始尺寸（统计量与尺寸无关）
    result = apply_transform(source, mean_src, std_src, mean_ref, std_ref)
    
    return result
```

**2. 缓存参考图像统计量**

```python
class CachedColorTransfer:
    def __init__(self):
        self.reference_stats = {}
    
    def transfer(self, source, reference_path):
        if reference_path not in self.reference_stats:
            ref_image = cv2.imread(reference_path)
            self.reference_stats[reference_path] = self._compute_stats(ref_image)
        
        return self._apply_transfer(source, self.reference_stats[reference_path])
```

### 6.2 背景合成优化

**1. 预处理背景图**

在加载时一次性调整背景尺寸，避免每次渲染都resize：

```python
self.background_cache = {}

def load_background(self, bg_path, target_size):
    if (bg_path, target_size) not in self.background_cache:
        bg = cv2.imread(bg_path)
        bg_resized = cv2.resize(bg, target_size)
        self.background_cache[(bg_path, target_size)] = bg_resized
    
    return self.background_cache[(bg_path, target_size)]
```

**2. 使用GPU加速**

如果使用GPU（CUDA），可以利用cupy加速：

```python
import cupy as cp

def gpu_composite(foreground_gpu, alpha_gpu, background_gpu):
    result_gpu = foreground_gpu * alpha_gpu + background_gpu * (1 - alpha_gpu)
    return cp.asnumpy(result_gpu)
```

---

## 参考资料

### 学术论文

1. **Reinhard et al. (2001)** - "Color Transfer between Images"
   - 经典的色彩迁移算法
   - https://www.cs.tau.ac.il/~turkel/imagepapers/ColorTransfer.pdf

2. **Pitié et al. (2005)** - "Automated colour grading using colour distribution transfer"
   - 更高级的直方图匹配方法

3. **Gatys et al. (2016)** - "Image Style Transfer Using Convolutional Neural Networks"
   - 神经网络风格迁移

### 实现参考

- **scikit-image**: 提供 `match_histograms` 函数
- **OpenCV**: 直方图计算和图像处理
- **ImageMagick**: 商业级色彩匹配工具

### 在线资源

- Adrian Rosebrock's Tutorial on Color Transfer: 
  https://pyimagesearch.com/2014/06/30/super-fast-color-transfer-images/

- Background Matting Techniques:
  https://grail.cs.washington.edu/projects/background-matting-v2/

---

## 总结

### 推荐实现路径

**阶段1（基础功能）**：
- 使用Reinhard算法实现色彩迁移
- 使用简单的Alpha混合实现背景合成

**阶段2（体验优化）**：
- 添加边缘羽化
- 提供参数调节UI
- 缓存优化

**阶段3（高级功能）**：
- 景深效果
- 多层合成
- 神经网络风格迁移（可选）

### 预期效果

- **色彩迁移**：渲染结果将自动采用参考图片的色调，如梵高画作的蓝黄色调
- **背景合成**：3D模型将自然地融入背景图片中，保持正确的遮挡关系

这两个功能将大大增强NPR渲染系统的艺术表现力和应用范围。
